% $Header$

\documentclass{beamer}

\usetheme{Darmstadt}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{textcomp}


% https://www.sharelatex.com/learn/Inserting_Images
\usepackage{graphicx}
\graphicspath{ {images/} }

\title{Design Principles}
\subtitle{aka Object Oriented Programming}
\author{Shaun Luttin}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Goal}

    \begin{itemize}
        \item Become vaguely familiar with these principles.
        \item Have a starting off point for further research.
    \end{itemize}

\end{frame}

\begin{frame}{Why?}

    \begin{itemize}
        \item Allow change (of system capacities) without redesign.
        \item Allow reuse in other applications.
    \end{itemize}

\end{frame}

\begin{frame}{Encapsulate what varies.}
    \begin{itemize}
        \item Encapsulate \ldots
            \begin{itemize}
                \item Restrict outside access to a thing's parts.
                \item Bundle operations with the things they use.
            \end{itemize}
        \item \ldots what varies.
            \begin{itemize}
                \item This refers to changes to source code.
                \item Source code changes due to changing requirements.
                \item Requirements change for a lots of reasons.
                \item E.g. A change in government may cause a change in tax law.
            \end{itemize}
        \item Restrict outside access to parts of the source code that might change due to changing requirements.
        \item ``what [do] you want to be \textit{able} to change without redesign?'' (Gamma et al, 1977)
    \end{itemize}
\end{frame}

\begin{frame}{Program to interfaces not to implementations.}
    \begin{itemize}
        \item an interface says only what requests it will receive
        \item an implementation says how it will handle those requests
        \item programming to interfaces helps because it
            \begin{itemize}
                \item lets us easily change an implementation, even at runtime
                \item allows applications to send the same request to different classes
            \end{itemize}
        \item Interface Segregation Principle (Martin, 1996)
        \item SOL\emph{I}D % solid
            \begin{itemize}
                \item Define an interface that is specific to the needs of the client.
                \item ``Clients should not be forced to depend upon interfaces that they do not use.'' (Martin, 1996)
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item interfaces and abstractions are similar: neither can exist
        \item concrete classes can exist (i.e. can become objects)
        \item to depend on something means a direct reference to it
        \item The Dependency Inversion Principle (Martin, 1996)
        \item SOLI\emph{D} % solid
        \begin{itemize}
            \item Traditionally, high-level modules depend on low-level modules:
            \item Higher \textrightarrow{} Middle \textrightarrow{} Lower \textrightarrow{} ...
            \item Dependency Inversion inverts that:
            \item Higher \textrightarrow{} Abstraction \textleftarrow{} Middle \textrightarrow{} Abstraction \textleftarrow{} Lower ...
        \end{itemize}
        \item When layering, higher-levels define the abstractions
        \item and lower-levels implement the abstractions.
        \item Why? Enable reuse of higher-level modules.
    \end{itemize}
\end{frame}

\begin{frame}{Only talk to your friends.}
    \begin{itemize}
        \item The Law of Demeter (Holland, 1987)
        \item aka The Princple of Least Knowledge
        \item Why? Promotes loose coupling via encapsulation.
        \item ``Only talk to your friends''
        \item ``Only use one dot'' 
            \begin{itemize}
                \item More than one dot is cause for reflection; 
                \item it is not necessarily a violation of the LoD.
                \item E.g. fluent interfaces use many dots.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{A class should have only one reason to change.}
    \begin{itemize}
        \item \emph{S}OLID % solid
        \item The Single Responsibility Principle (Martin, 2003)
        \item ``A class should have only one reason to change''
        \begin{itemize}
            \item Recall from ``encapsulate what varies.''
            \item This refers to changes to source code.
            \item Source code changes due to changing requirements.
        \end{itemize}
    \item Why? 
        \begin{itemize}
            \item (Re)use feature X without bringing feature A-Z.
            \item Change feature X without breaking/recompiling what depends on feature A-Z.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Don't call us, we'll call you.}
    \begin{itemize}
        \item "Hollywood Principle" (Sweet, 1983)
        \item "Inversion of Control" (Johnson and Foote, 1988)
            \begin{itemize}
                \item Dependency injection is a type of Inversion of Control
                \item IoC containers are a type of Dependency Injection
            \end{itemize}
        \item Dependency Inversion - who owns the abstraction?
        \item Inversion of Control - when do things happen?
        \item "coordinating and sequencing application activity"         
        \item "makes a framework different from a library":
            \begin{itemize}
                \item library: "a set of functions you can call"
                \item framework: "insert your behavior into various places"
            \end{itemize}
        \item How? subclassing, implementing iterfaces, binding/events
    \end{itemize}
\end{frame}

\begin{frame}{Classes should be open to extension and closed for modification.}
    \begin{itemize}
        \item S\emph{O}LID % solid
        \item The Open-Closed Principle
        \item Once it is shipped, the source code is sacrosanct.
        \item Rather than change the source code and risk breaking it, 
        \item extend the source code via inheritance or wrapping. 
        \item E.g. the Decorator Pattern (Gamma et al, 1977)
    \end{itemize}
\end{frame}

\begin{frame}{Favour composition over inheritance.}
    \begin{itemize}
        \item Composition means a has-a relationship.
            \begin{itemize}
                \item It is often more semantically natural.
                \item It lets us swap implementations at runtime.
            \end{itemize}
        \item Inheritance means an is-a relationship.
            \begin{itemize}
                \item Tall class heirachies are brittle.
                \item Changing an implementation is limited to compile time.
                \item It is harder to do correctly.
            \end{itemize}
        \item The Liskov Substitution Principle (Liskov and Wing, 1994)
            \begin{itemize}
                \item SO\emph{L}ID % solid
                \item A consumer that is expecting A, 
                \item should have no surprises on receiving a child of A.
                \item Compilers do not help: this is a semantic syntactic contraint.
                \item e.g. class Hemlock should probably not inherit class Vegetable.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Strive for loosely coupled designs among objects that interact.}
    \begin{itemize}
        \item This is the summary statement for all the princples.
        \item When loosely coupled, we can \ldots
        \item \ldots change X without needing to change Y, and
        \item \ldots use X without needing to bring along Y.
    \end{itemize}
\end{frame}

\end{document}

